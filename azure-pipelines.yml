# Copyright (c) .NET Foundation and Contributors
# See LICENSE file in the project root for full license information.

trigger:
  branches:
    include:
      - main
      - develop
      - release-*
  paths:
    exclude:
      - .github_changelog_generator
      - .gitignore
      - CHANGELOG.md
      - CODE_OF_CONDUCT.md
      - LICENSE.md
      - README.md
      - NuGet.Config
      - assets/*
      - config/*
      - .github/*
    
# PR always trigger build
pr:
  autoCancel: true

# add nf-tools repo to resources (for Azure Pipelines templates)
resources:
  repositories:
    - repository: templates
      type: github
      name: nanoframework/nf-tools
      endpoint: nanoframework

jobs:

##############################
- job: Check_Build_Options
  pool:
    vmImage: 'windows-latest'

  steps:
  
  - checkout: self
    fetchDepth: 1
    clean: true

  # get commit message
  - task: PowerShell@2
    name: EvaluateBuildOptions
    displayName: Evaluate CI build type
    inputs:
      targetType: 'inline'
      script: |
        # default to false
        $update = $false

        if($env:System_PullRequest_PullRequestId -ne $null)
        {
            # PR build, nothing interesting in commit message
            Write-Host "Build from PR"
        }
        else
        {
            if($env:StartReleaseCandidate -like "true")
            {
                # this is a release prep so NO build
                echo "##vso[task.setvariable variable=SKIP_BUILD;isOutput=true]true"
                Write-Host "Release preparation, skipping build."
            }
            else
            {
                # build NOT from PR
                Write-Host "Build NOT from PR, commit ID: $env:Build_SourceVersion"
                # get PR associated with commit
                $prUrl = "https://api.github.com/repos/$env:Build_Repository_Name/commits/$env:Build_SourceVersion/pulls"
                $commit = Invoke-RestMethod -Uri $prUrl -ContentType "application/json" -Headers @{"Accept"="application/vnd.github.groot-preview+json"} -Method GET
            }
        }
  
        # set variable to foward to jobs
        echo "##vso[task.setvariable variable=RUN_UPDATE_DEPENDENTS;isOutput=true]$update"


  - task: PowerShell@2
    condition: eq( variables['StartReleaseCandidate'], true)
    displayName: NBGV prepare release
    inputs:
      targetType: 'inline'
      script: |
        # compute authorization header in format "AUTHORIZATION: basic 'encoded token'"
        # 'encoded token' is the Base64 of the string "nfbot:personal-token"
        $auth = "basic $([System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("nfbot:$(GitHubToken)"))))"

        cd "$env:Agent_TempDirectory" > $null

        Write-Host "Cloning from: $env:BUILD_REPOSITORY_URI"

        git clone $env:BUILD_REPOSITORY_URI repo
        cd repo > $null
        git config --global gc.auto 0
        git config --global user.name nfbot
        git config --global user.email nanoframework@outlook.com
        git config --global core.autocrlf true
        
        Write-Host "Checkout main branch..."
        git checkout --quiet main  > $null

        # prepare release and capture output
        Write-Host "Prepare release with NBGV..."
        $release = nbgv prepare-release
    
        Write-Host "Prepare commit..."
        # get commit message for the merge
        $commitMessage = git log -1 --pretty=%B

        # amend commit message to skip build
        git commit --amend -m "$commitMessage" -m "***NO_CI***" > $null

        Write-Host "Pushing changes to GitHub..."
        # push all changes to github
        git -c http.extraheader="AUTHORIZATION: $auth" push --quiet --all origin

        # get release branch name
        $branch = $release.Split(' ')[0]

        Write-Host "Prepare PR..."
        # start PR for release
        $prRequestBody = @{title="Release $branch";body="";head="$branch";base="main"} | ConvertTo-Json
        $githubApiEndpoint = "https://api.github.com/repos/$env:BUILD_REPOSITORY_NAME/pulls"
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

        $headers = @{}
        $headers.Add("Authorization","$auth")
        $headers.Add("Accept","application/vnd.github.symmetra-preview+json")

        try 
        {
            $result = Invoke-RestMethod -Method Post -UserAgent [Microsoft.PowerShell.Commands.PSUserAgent]::InternetExplorer -Uri  $githubApiEndpoint -Header $headers -ContentType "application/json" -Body $prRequestBody
            'Started PR for new release...' | Write-Host -NoNewline
            'OK' | Write-Host -ForegroundColor Green
        }
        catch 
        {
            $result = $_.Exception.Response.GetResponseStream()
            $reader = New-Object System.IO.StreamReader($result)
            $reader.BaseStream.Position = 0
            $reader.DiscardBufferedData()
            $responseBody = $reader.ReadToEnd();

            "Error starting PR: $responseBody" | Write-Host -ForegroundColor Red
        }
      workingDirectory: $(Agent.TempDirectory)
      ignoreLASTEXITCODE: true

###########################################################
# build tool
- job: Build_tool
  condition: >-
    and(
      succeeded(),
      ne(dependencies.Check_Build_Options.outputs['EvaluateBuildOptions.SKIP_BUILD'], true)
    )
  dependsOn:
  - Check_Build_Options
  timeoutInMinutes: 30

  pool:
    vmImage: 'windows-latest'

  variables:
    toolname: 'nanoFrameworkDeployer'
    buildPlatform: 'Any CPU'
    buildConfiguration: 'Release'
    isTag: $[startsWith(variables['Build.SourceBranch'], 'refs/tags/v')]
    ContinuousIntegrationBuild: true
    run_update_dependents: $[dependencies.Check_Build_Options.outputs['EvaluateBuildOptions.RUN_UPDATE_DEPENDENTS']]
    GH_TOKEN: $(GitHubToken)

  steps:

  # need this here in order to persist GitHub credentials
  - checkout: self
    fetchDepth: 1
    clean: true
    persistCredentials: true

  - script: |
      git config --global user.email "nanoframework@outlook.com"
      git config --global user.name "nfbot"
    displayName: Setup git identity

  # - task: Cache@2
    #   displayName: Cache dotnet SDK
  #   inputs:
  #     key: 'dotnet | $(Agent.OS) | $(dotnet)'
  #     restoreKeys: |
  #       dotnet | $(Agent.OS) | $(dotnet)
  #       dotnet $(dotnet)
  #     path: $(Agent.ToolsDirectory)/dotnet

  - task: UseDotNet@2
    displayName: Install .NET SDK
    inputs:
      packageType: sdk
      version: 6.x

  - task: Cache@2
    displayName: Cache NuGet packages
    inputs:
      key: 'nuget | "$(Agent.OS)" | **/packages.lock.json, !bin/**'
      restoreKeys: |
          nuget | "$(Agent.OS)"
          nuget
      path: $(UserProfile)/.nuget/packages

  # Set CI build version
  # See: https://github.com/dotnet/Nerdbank.GitVersioning/blob/main/doc/cloudbuild.md
  # Generally only used to update dependents (such as changelog)
  - script: nbgv cloud -a -c
    condition: >-
        eq(variables['UPDATE_DEPENDENTS'], 'true')
    displayName: Set CI build Version

  #- task: DotNetCoreCLI@2
  #  displayName: Restore NuGet packages
  #  condition: >-
  #    and(
  #      succeeded(),
  #      eq(variables['UPDATE_DEPENDENTS'], 'false')
  #    )
  #  inputs:
  #    command: restore
  #    restoreArguments: ' --locked-mode --force-evaluate '
  #    verbosityRestore: minimal
  #    projects: '$(toolname).sln'
  #    feedsToUse: config
  #    nugetConfigPath: NuGet.Config

  # only setup sonar if a PR
  - task: SonarCloudPrepare@1
    condition: >-
      and(
        succeeded(),
        ne(variables['System.PullRequest.PullRequestId'], '')
      )
    displayName: 'Prepare SonarCloud'
    inputs:
      SonarCloud: 'sonarcloud-nanoFrameworkDeployer'
      organization: 'nanoframework'
      scannerMode: 'MSBuild'
      projectKey: 'nanoframework_nanoFrameworkDeployer'

  - task: DotNetCoreCLI@2
    displayName: Build Solution
    condition: >-
      and(
        succeeded(),
        eq(variables['UPDATE_DEPENDENTS'], 'false')
      )
    inputs:
      command: 'build'
      projects: '$(toolname).sln'
      arguments: '--configuration $(BuildConfiguration) /p:ContinuousIntegrationBuild=true --verbosity normal /nr:false'

  ##################################################

  - task: DotNetCoreCLI@2
    displayName: 'Run Unit Tests'
    condition: >-
      and(
        succeeded(),
        ne(variables['System.PullRequest.PullRequestId'], '')
      )
    inputs:
      command: test
      projects: ./$(toolname).Tests/$(toolname).Tests.csproj
      nobuild: true
      arguments: '--configuration $(BuildConfiguration) --collect "XPlat Code coverage"'
      publishTestResults: true

  # First install the tool on the machine, then run it
  - task: PowerShell@2
    displayName: 'Create code coverage report'
    condition: >-
      and(
        succeeded(),
        ne(variables['System.PullRequest.PullRequestId'], '')
      )
    inputs:
      targetType: 'inline'
      script: |
        dotnet tool install -g dotnet-reportgenerator-globaltool
        reportgenerator -reports:$(Agent.WorkFolder)/**/coverage.cobertura.xml -targetdir:$(Build.SourcesDirectory)/CodeCoverage "-reporttypes:HtmlInline_AzurePipelines;Cobertura;SonarQube"


  - task: PublishCodeCoverageResults@1
    displayName: 'Publish code coverage results'
    condition: >-
      and(
        succeeded(),
        ne(variables['System.PullRequest.PullRequestId'], '')
      )
    inputs:
      codeCoverageTool: Cobertura
      summaryFileLocation: '$(Build.SourcesDirectory)/**/Cobertura.xml'

##################################################

  # only run sonar if a PR
  - task: SonarCloudAnalyze@1
    displayName: 'Run static analysis on SonarCloud'
    condition: >-
      and(
        succeeded(),
        ne(variables['System.PullRequest.PullRequestId'], '')
      )

  # If still an issue relate to line 303 of: https://github.com/SonarSource/sonar-dotnet/blob/master/azure-pipelines.yml
  # TODO: will be commented out until we can fix it! But it is actually already published already...
  # only publish sonar if a PR
  # - task: SonarCloudPublish@1
  #   displayName: 'Publish static analysis from SonarCloud'
  #   condition: >-
  #     and(
  #       succeeded(),
  #       ne(variables['System.PullRequest.PullRequestId'], '')
  #     )
  #   inputs:
  #     pollingTimeoutSec: '300'

####################################################

  # pack artifacts
  # Pack the solution with the --no-build argument.
  # You may need to pass additional parameters here, such as /p:PackageVersion="$(PackageVersion)".
  - task: DotNetCoreCLI@2
    condition: >-
      and(
        succeeded(),
        eq(variables['UPDATE_DEPENDENTS'], 'false')
      )
    displayName: 'Pack nuget'
    inputs:
      command: custom
      projects: '$(toolname).sln'
      custom: pack
      arguments: '--configuration $(buildConfiguration) --output "$(Build.ArtifactStagingDirectory)/$(toolname)" --no-build --verbosity normal'

  - task: PowerShell@2
    condition: >-
      and(
        succeeded(),
        eq(variables['UPDATE_DEPENDENTS'], 'false')
      )
    displayName: Check/Set NuGet build number
    inputs:
      targetType: 'inline'
      script: |
        $MyNuGetVersion = $env:NBGV_NuGetPackageVersion -replace "\-g$env:NBGV_GitCommitIdShort", ""

        # replace preview with alpha if this is a PR build
        if($env:System_PullRequest_PullRequestId -ne $null)
        {
          $MyNuGetVersion = $MyNuGetVersion -replace "preview", "alpha"
        }

        Write-Host "NuGet build number is $MyNuGetVersion"

        Write-Host "$("##vso[task.setvariable variable=MY_NUGET_VERSION]")$MyNuGetVersion"

  # update CI build number (only possible if this is not a PR from a fork)
  # if changed after thee previous task?!
  - task: PowerShell@2
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        eq(variables['UPDATE_DEPENDENTS'], 'false')
      )
    displayName: Update build number
    inputs:
        targetType: 'inline'
        script: |
          Write-Host "$("##vso[build.updatebuildnumber]")$env:NBGV_NuGetPackageVersion"

  - task: powershell@2
    displayName: Set release type
    condition: >-
      and(
        succeeded(),
        eq(variables['UPDATE_DEPENDENTS'], 'false')
      )
    inputs:
      targetType: 'inline'
      script: |
        # get subject and commit message for commit
        $commitMessage = git log --format='%B' -1

        # need to flatten message by removing new lines
        $commitMessage = $commitMessage -replace "`r`n", " "

        if($commitMessage -like "***PUBLISH_RELEASE***")
        {
          # set variable
          Write-Host "$("##vso[task.setvariable variable=RELEASE_DRAFT]")false"
          Write-Host "Release draft: FALSE"
        }
        else
        {
          # set variable
          Write-Host "$("##vso[task.setvariable variable=RELEASE_DRAFT]")true"
          Write-Host "Release draft: TRUE"
        }

  - task: CopyFiles@1
    condition: >-
      and(
        succeeded(),
        eq(variables['UPDATE_DEPENDENTS'], 'false')
      )
    displayName: Collecting deployable artifacts
    inputs:
      sourceFolder: $(Agent.BuildDirectory)
      Contents: |
        **\*.nupkg
      TargetFolder: '$(Build.ArtifactStagingDirectory)'
      flattenFolders: true

  - task: DotNetCoreCLI@2
    displayName: Install SignTool tool
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        eq(variables['UPDATE_DEPENDENTS'], 'false')
      )
    inputs:
      command: custom
      custom: tool
      arguments: install --tool-path . SignClient

  - task: powershell@2
    displayName: Sign packages
    continueOnError: true
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        eq(variables['UPDATE_DEPENDENTS'], 'false')
      )
    inputs:
      targetType: 'inline'
      script: |
        .\SignClient "Sign" `
        --baseDirectory "$(Build.ArtifactStagingDirectory)" `
        --input "**/*.nupkg" `
        --config "$(Build.Repository.LocalPath)\config\SignClient.json" `
        --filelist "$(Build.Repository.LocalPath)\config\filelist.txt" `
        --user "$(SignClientUser)" `
        --secret '$(SignClientSecret)' `
        --name ".NET nanoFramework Deployer" `
        --description ".NET nanoFramework Deployer" `
        --descriptionUrl "https://github.com/$env:Build_Repository_Name"
    
  # publish artifacts
  - task: PublishBuildArtifacts@1
    condition: >-
      and(
        succeeded(),
        eq(variables['UPDATE_DEPENDENTS'], 'false')
      )
    displayName: Publish deployables artifacts
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)'
      ArtifactName: deployables
      ArtifactType: Container

  # push NuGet class lib package to NuGet (happens on all builds except PRs)
  - task: NuGetCommand@2
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        eq(variables['UPDATE_DEPENDENTS'], 'false')
      )
    displayName: Push nanoframeworkDeployer NuGet package to NuGet
    continueOnError: true
    inputs:
      command: push
      feedsToUse: select
      nuGetFeedType: external
      allowPackageConflicts: true
      packagesToPush: '$(Build.ArtifactStagingDirectory)\$(toolname).$(NBGV_NuGetPackageVersion).nupkg'
      publishFeedCredentials: 'NuGet-nanoFrameworkDeployer'

  # push NuGet class lib package to NuGet (happens on all builds except PRs)
  - task: NuGetCommand@2
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        eq(variables['UPDATE_DEPENDENTS'], 'false')
      )    
    displayName: Push library NuGet package to Azure Artifacts
    continueOnError: true
    inputs:
      command: push
      feedsToUse: select
      nuGetFeedType: external
      allowPackageConflicts: true
      packagesToPush: '$(Build.ArtifactStagingDirectory)\$(toolname).$(NBGV_NuGetPackageVersion).nupkg'
      publishFeedCredentials: 'AzureArtifacts-nanoFrameworkDeployer'

  # create or update GitHub release
  - task: GithubRelease@1
    condition: >-
      and(
        succeeded(),
        eq(variables['System.PullRequest.PullRequestId'], ''),
        eq(variables['UPDATE_DEPENDENTS'], 'false')
      )
    displayName: Create/Update GitHub stable release
    inputs:
      gitHubConnection: 'github.com_nano-$(System.TeamProject)'
      tagSource: userSpecifiedTag
      tag: v$(MY_NUGET_VERSION)
      title: 'nanoFramework Deployer Library v$(NBGV_NuGetPackageVersion)'
      assets: '$(Build.ArtifactStagingDirectory)/*.nupkg'
      isPreRelease: false
      action: create
      isDraft: false
      addChangeLog: true
      changeLogLabels: |
        [
          { "label" : "Type: bug", "displayName" : "Bugs fixed", "state" : "closed" },
          { "label" : "Type: enhancement", "displayName" : "Enhancements and new features", "state" : "closed" },
          { "label" : "Breaking-Change", "displayName" : "Breaking Changes", "state" : "closed" }
          { "label" : "Type: dependencies", "displayName" : "Dependencies updated", "state" : "closed" },
          { "label" : "Type: documentation", "displayName" : "Documentation", "state" : "closed" }
        ]

##################################
  # update dependents
  - task: PowerShell@2
    condition: >-
      or(
        eq(variables['UPDATE_DEPENDENTS'], 'true'),
        eq(variables['run_update_dependents'], 'true')
      )
    displayName: Update dependent tools
    inputs:
      targetType: filePath
      filePath: azure-pipelines/update-dependents.ps1
    env:
      GH_TOKEN: $(GitHubToken)

##################################
# report build failure to Discord
- job: Report_Build_Failure
  dependsOn:
  - Check_Build_Options
  - Build_tool
  condition: >-
    or(
      failed('Check_Build_Options'),
      failed('Build_tool')
    )

  pool:
    vmImage: 'windows-latest'

  steps:
  - checkout: self

  # step from template @ nf-tools repo
  - template: azure-pipelines-templates/discord-webhook.yml@templates  
    parameters:
      status: 'failure'
      webhookUrl: '$(DiscordWebhook)'
      message: ''
